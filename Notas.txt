Módulo 02: MVC Basics - CRUD Operation

01. Modelo Category

02. DataAnnotations como Key, Required, etc.

03. Cadena de conexión

04. ApplicationDbContext. Para que acepte DBContext
	Instalar:
	Microsoft.EntityFrameworkCore

05. Configurar el DbContext en Program. Para que acepte el UseSqlSever
	Instalar:
	Microsoft.EntityFrameworkCore.SqlSever

06. Crear la migracion y actualizar la BD. Para que acepte los comandos
	Instalar:
	Microsoft.EntityFrameworkCore.Tools

	Add-Migration AddCategoryToDatabase
	Update-database

10. Descargamos el bootstrap theme "Solar" de la pagina
    https://bootswatch.com/

	Se trata de Bootstrap pero con un thema especifico.
	Al momento de llevar el curso la version del thema esta en 5.2.3

	Creamos el archivo
	En wwwroot/css/bootstrapTheme.css
	Y pegamos la hoja de estilos descargada de bootswatch.com

	En Layout, reemplazamos la hoja de estilos de bootstrap que usa por defecto y 
	apuntamos a la creada "bootstrapTheme.css"
	<link rel="stylesheet" href="~/css/bootstrapTheme.css" />

	Agregamos, ademas, el javascript bundle de bootstrap conseguido en su pagina
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>

11. Para usar iconos de bootstrap
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

	Uso: <i class="bi bi-plus-circle"></i>

	https://icons.getbootstrap.com/

16. Para activar la valizadion el cliente (unobstrusive). Agregar lo sgte en la pagina donde se
    desea la validacion
	@section Scripts {
    @{
        <partial name="_ValidationScriptsPartial" />
    }

21. Lo alamacenado en TempData permanece ahi solo por un request, luego desaparce, al igual que
    si referescamos la pagina

23. Uso de toastr:
	https://github.com/CodeSeven/toastr

	Copiar en Layout:
	https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css

	Uso:
	<script src="~/lib/jquery/dist/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
    if (TempData["success"] != null)
    {
        <script type="text/javascript">
            toastr.success('@TempData["success"]');
        </script>
    }

	* Es necesario tener la referencia a jquery y al script de toastr donde queremos utilizar
	toastr

	Como vamos a usar las notificacioanes en muchas páginas ñpodemos usar la etiqueta partial
	(que llama a la vista partial e notificaciones) en una vista más general como por ejm
	Layout.

	<main role="main" class="pb-3">
        <partial name="_Notification" />
        @RenderBody()
    </main>

=========================================================================================================

Módulo 04: N-Tier Architecture

01. Creación del resto de proyectos:
	DataAccess
	Models
	utility

02. Hacer refactoring al proyecto. Asegurarnos que los sgtes paquetes esten en
    DataAcces para que esto funcione:

	Microsoft.EntityFrameworkCore
	Microsoft.EntityFrameworkCore.SqlSever
	Microsoft.EntityFrameworkCore.Tools

=========================================================================================================

Módulo 05: Repository Pattern

04. Implementando CategoryRepository, inicialmente con Category

06. Implementando Unit Of Work, inicialmente con CategoryRepository

09. Luego de la creacion de la estructura del proyecto y mover los modelos, DbContext y carpeta
    Migrations a otros proyectos.
	Al momento de crear las migracions y actualizar la BD, asegurarse de tener como
	Proyecto prederteminado a BUlkyBook.DataAccess en la consola de Administración de Paquetes

    Asignación:
	Creacion del modelo CoverType, su repositorio correspondiente y sus uso con UnitOFWork.
	Creacion de la migracion correspondiente y actualizacion de la BD
	Ver video: 009 Assignment 1 Solution - Cover Type Repository

10. Implementacion de Areas.
	La idea es tener un area para Admin y otra para Customers

	Click derecho en el Proyecto web / Agregar / Nuevo elemento con Scaffold / Area de MVC
	Le damos el nombre Admin
	Hacemos lo mismo para crear el area Customer

	En Program.cs como ahora vamos a usar Areas, editamos el app.MapControllerRoute.
	Ahora pattern será:
	pattern: "{area=Customer}/{controller=Home}/{action=Index}/{id?}");

	Podemos borrar las carpetas Data y Models en las areas creada, pues lo estamos manejando
	en proyectos separados.
	Ahora podemos organizar nuestros controladors y vistas.

11. CategoryController y las vistas de Category moverlas a las carpetas correspondientes en
	el Area Admin. Lo mismo con HomeController y las vistas de Home hacia el Area Customer.

	Mover el archivo _ViewImports.cshtml a las carpetas Views de cada Area para que las vistas puedan
	reconocer los namespaces de los modelos que utilizan (Ejm: Category)

	Movemos tambien el archivo _ViewStart.cshtml a las carpetas Views de cada Area para que 
	puedan detectar el archivo _Layout.cshtml es decir nuestro MasterPage.

	Agregar a los enlaces en _Layout.cshtml el atributo asp-area para inidicar con exactitud
	donde se encuentra ahora la pagina a la que queremos ir
	<a class="nav-link" asp-area="Admin" asp-controller="Category" asp-action="Index">Category</a>

	Ya estando en http://localhost:5212/Admin/Category, al querer ir a otra URl como la de 
	"Crear nueva categoria", el controlador y la vista correspondientes serán buscadas en la
	misma Area en la que uno se encuentra, es decir "Admin". 
	http://localhost:5212/Admin/Category/Create
	Si el controlador y la vista a la que queremos ir estarian en otra Area tendriamos que 
	especificarlas en el enlace con asp-area.

13. Asignación:
	Creacion el controlador CoverType con sus vistas correspondientes en el Area Admin.
	Prueba de su correcto funcionamiento.
	Ver video: 013 Assignment 2 Solution - Cover Type Controller and Views

=========================================================================================================

Módulo 06: Product Management

01. Creamos el modelo producto

02. Creamos el DbSet respectivo
	Creamos la migración y actualizamos la BD
	Add-Migration AddProductToDb
	Update-Database

	Asegurarse de tener como proyecto predeterminado en la consola se administracion de paquetes
	BulkyBook.DataAccess

03. Cracion de ProductRepository y uso en UnitOfWork

04. Cracion de ProductController y la vista Index
	Las vistas para este controlador seran un tanto distintas a las vistas de los otros controladores

05. Creacion de la vista Upsert

06. Obtener y configurar los items para los drop down category y cover type usando
    proyecciones con select

07. Colocando la lista de categorias en ViewBag y usandola en la vista

08. Colocando la lista de cover type en ViewData y usandola en la vista
    Además diferencias entre Viewbag, ViewData y TempData en el video

09. Uso de un ViewModel. Colocar en el ViewModel propiedades que contengan las listas con
    las que vamos a llenar los drop downs de nuestra vista.
	Es un mejor enfoque que usar ViewData o ViewBag

10. Agregación de File Upload y formato al formulario Upsert

11. Uso de SweetAlert en Upsert.cshtml
	https://sweetalert2.github.io/

	El subir una imagen es obligatorio al registrar pero no al actualizar

12. Accediendo a wwwroot con IWebHostEnvironment para guardar la imagen subida
	OJO: En el ViewModel y el Modelo hay que colocar [ValidateNever] para que ModelState.IsValid
	no lo valide, NET 6 es estricto con desde el momento que una vista esta enlazada a un modelo
	o view model. De toda maneras no se deberia usar el modelo completo como una propiedad dentro
	del view model. Es mejor copiar las propiedes del modelo al viewmodel, agregar las que 
	necesitemos y hacer las validaciones necesarias en el view model.

13. Uso de DataTables
	https://datatables.net/
	Copiar cdn del CSS y JS en Layout

	Creacion de un endpoint dentro del controlador de productos, que sera consumido por el
	Data Table para cargar la informacion

14. Cargamos los productos en el Data Table con el endpoint en API CALL, usando el arhivo
    product.js que es agregado en Indx en la sección Scripts

15. Interesante lo de incluir en las consultas opcionalmente las propiedade que se desean.
	Pero luego de obtener esa informacion en el modelo Producto, hay dos maneras de manejarla
	a nivel de ViewModel.
	1.Mapeamos la info hacia el view model con AutoMapper. En este caso el view model tambien 
	  tendria que tener sus propias propiedades de navegacion (CategoryVM, CoverTypeVM) y el
	  mapper se encargaria se hacer el trabajo de pasar los valores.
	2.Mapeamos la info hacia el view model con AutoMapper. En este caso el view model tiene solo
	  las propiedades individuales necesarias (CategoryName, CoverTypeName) y el mapper se encargaria
	  de pasar la info pero especificandolo en su configuracion (ver curso de API REST de Gavilan).
	  La idea es configurar que de la propiedad de navegacion del modelo Product solo necesito el
	  nombre y se lo asigno a la propiedad CategoryName del view model

	NOTA: Si no se reflejan los cambios hechos en el script hacer Ctrl + F5 para actualizarlo
	en caché.

16. Renderizando los botones de editar y eliminar en el data table. Notar que en el 
	rendrizado no funcionan los tag helpers, por lo que ha yque usar "href" escribiendo la 
	ruta y pasando el id como parametro

17. Cargar la información del producto en el formulario upsert

18. Actualizar la informacion del producto. Notar el hidden con el id del producto en el
	formulario upsert

19. Actualizar la imagen del producto. Notar que se elimina la vieja imagen y se guarda la
	nueva. Notar tambien  el hidden con la url de la imagen del producto en elformulario upsert
	Además se modificó la estructura del formulario upsert para agregar una columna a la 
	derecha donde se mustra una imagen previa del producto.

20. Para eliminar el producto se utilizará un API endpoint como se hizo para cargarlos en la lista
	No se usará los actions tradicionales para borrar
	Se copió el CDN de toastr en Layout para utlizarlo en el mensajae de exito al eliminar

21. Se creó el método deleteProduct en product.js 
	En este metodo se combina sweet alert y toastr. Se usa sweet alert para mostrar un popup
	de confirmación de eliminacion. Y se usa toastr para mostrar el mensaje final de 
	exito o falla en la eliminación
	https://sweetalert2.github.io/
	Notar en product.js en el renderizado de los botones en el data table, la difernencia entre
	la url usada para conectarse a un action normal de la aplicacion y la url usada para 
	conectarse a un endpoint del api usando ajax.
	Notar tambien com se recarga el datatable asincronamente con los nuevos datos luego de
	una eliminacion exitosa
	dataTable.ajax.reload()

22. Se copió en Layout el CDN para manejar tiny MCE
	https://www.tiny.cloud/
	El código que creará el editor esta en la sección de scripts de la página upsert.
	Este codigo actua sobre el textarea

=========================================================================================================

Módulo 07: Home Page

01. Se modificó la vista Index de Home para mostrar un listado responsive de los libros,
	usando cards. Cada card muestra la imagen e info del libro. Además tiene un botón Details.

03. Creamos el model ShoppingCart y el Action Details 

04. Creamos la vista detail haciendo uso de snippet proveido por el instructor.
	Notar el uso de la clase bootstrap CSS badge para la categoria y el cover type.
	Notar tambien el uso de @Html.Raw(Model.Product.Description) para mostrar el
	valor de descripcion. Se debe usar Html.Raw para que borre de la descripcion tags
	como <p>, <b>, <br>, etc. ya que la descripcion es ingresada a traves de un editor y se
	guarda con ese tipo de tags.

=========================================================================================================

Módulo 08: Identity Management

01. Scaffold Identity
	
	A. Instalar en el proyecto BulkyBook.DataAccess:
		Microsoft.AspNetCore.Identity.EntityFrameworkCore

	B. Hacemos que nuestro contexto herede de IdentiyDbContext
		public class ApplicationDbContext : IdentityDbContext

	C. Click derecho en BulkyBookWeb / Agregar / Nuevo elemento con Scaffold
	   Seleccionamos en la izquierda Identity y en las plantillas tambien Identity. Aceptar
	   En la pantalla para el scaffold:
	   1. Si no vamos a utilizar otra "master page" dejamos el campo en blanco. Eso significa
		  que vamos a utilziar el _Layout
	   2. Seleccionamos las paginas que deseamos crear en nuestro proyecto.
	   3. Seleccionamos el ApplicationDbContext que ya hereda de IdentityDbContext
	   4. Aceptamos

	D. Vemos que en la carpeta Areas se ha creado una carpeta Identity con todo el scaffold realizado.
	
	E. Si en Program.cs se creara otro builder.Services.AddDbContext, lo borramos ya que vamos a 
	   utilizar el ApplicationDbContext del proyecto.
	
	F. En Program se habra creado un linea que nos dice que Identity usara el usuario por defecto
	   IdentityUser y que se utilizara EntityFramework.
	   Si vemos mas abajo en los middlewares, se ha añadido el middleware app.UseAuthentication();
 
    G. Si en la carpeta Areas/Identity se creara una carpeta Data y dentro un archivo
	   ApplicationDbContext, borrar la carpeta, pues ya tenemos un ApplicationDbContext en el 
	   proyecto BulkyBook.DataAccess
    
	H. En Views/Shared podemos ver que se ha incluido una vista parcial _LoginPartial.cshtml que
	   sera usada para añadir las opciones de Login y Register en nuestra aplicacion.

02. En _Layout agregamos la vista parcial Views/Shared/_LoginPartial.cshtml para poder tener
    las opciones de registro y login en nuestra barra de navegación

03. Para que las opciones Register, Login, etc. que llaman a paginas razor, funcionen, hay que
    añadir el sgte servicio en Program.cs
	builder.Services.AddRazorPages();

	Y el sgte middleware
	app.MapRazorPages();

	Esto es porque las paginas razor tiene otra forma de ser invocadas, usan asp-page en lugar
	de asp-action que se usa en MVC.

	Se agrego la migracion con la cual crearemos las tablas identity en la BD.
	Asegurarse de tener como predeterminado el proyecto BulkyBook.DataAccess
	Add-Migration AddIdentityToDb
	Update-Database

04. Registrarse en la aplicacion. Si aparecieran errores de modelo no valido, ver video
    para posible solucion. 
	En mi caso, al hacerlo, me registre sin problemas.
	Usuario: jzo2102@mail.com
	Password: K@ncerbero80

06. Instalar Microsoft.Extensions.Identity.Stores en BulkyBooks.Models para poder tener el 
    namespace Microsoft.AspNetCore.Identity y asi poder usar IdentiyUser.
	La idea es crear el modelo ApplicationUser que extienda de IdentityUser porque nscesitamos
	guardar más datos del usuario que solo los que proporciona AspNetUsers a traves de Identity

	Creamos el DbSet respectivo para ApplicationUser, creamos una migracion y actualizamos la BD
	Contrariamente a lo que se puede creer , esto no creara una tabla de nombre ApplicationUser,
	sino que agregará los campos a la tabla AspNetUsers ya existente.

	NOTA: La migracion creo automaticamente un campo llamado "Discriminator", y este campo sirve
	para saber si el usuario fue creado a traves de IdentityUser o a traves de ApplciationUser

08. Crecion del Modelo Company
	DbSet Companies
	Migracion y Update de BD
	Creacion de Repositorio (Interface y Clase)
	Uso de repositorio en UOW (Interface y Clase)
	Creacion del controlador CompanyController
	Creacion de las vistas Index y Upsert para Company
	Creacion del archivo javasript company.js
	Agregamos la opcion Company en Content Management en _Layout
	Probamos el CRUD de Company

09. En Program.cs para trabajar con roles cambiamos:
	builder.Services.AddDefaultIdentity<IdentityUser>().AddEntityFrameworkStores<ApplicationDbContext>();
	Por:
	builder.Services.AddIdentity<IdentityUser, IdentityRole>().AddDefaultTokenProviders()
    .AddEntityFrameworkStores<ApplicationDbContext>();

	Esto es porque cuando queremos utilizar un custom identity (ademas con IdentityRole) y ya 
	no un default identity, tenemos que habilitar DefaultTokenProviders ya que tenemos que 
	ser explicitos en que vamos a utilizar genracion de tokens (se refiere a tokens de 
	confirmacion al momento del registro de un usuario).

10. Tendriamos que crear los roles en la BD con Seed Data al momento de ingresar a la aplicacion,
	o tener un Crud para crear nuestro roles.
	Pero ya que este es un demo, se aprovechará el RegisterModel para crear los roles
	- Obtenemos una instancia de RoleManager
	- En OnGet Creamos los roles de la aplicacion
	- En la clase SD estan las constantes con los roles de la aplicacion

	OJO: UNA VEZ QUE DEJAMOS DE USAR DEFAULTIDENTITY HAY VARIAS COSAS QUE YA NO SE HACEN POR
	     DEFECTO Y QUE TENEMOS QEU HACERLAS MANUALMENTE PARA QUE LA APLICACION FUNCIONE.
		 EJM: 
		 RegisterModel tiene inyectada una instancia de IEmailSender. Esta instancia se inyecta
		 automaticamente cuando usas DefaultIdentity, pero si usas un custom Identity se tiene
		 que crear manualmente una clase que implemente IEmailSender y registrar el servicio
		 en Program.cs

    Entonces, dicho lo anterior, vamos a crear por ahora una clase fake EmailSender que implemente la 
	interfaz IEmailSender. Esto lo creamos en BulkyBook.Utility
	Luego registramos el servicio en Program.cs
	builder.Services.AddSingleton<IEmailSender, EmailSender>();

	Ahora al ingresar a la opcion Register, se crearán los roles en la BD

11. En la configuracion de la clase InputModel en RegisterModel, creamos mas campos que vamos a
    necesitar al momento de que se registre un usuario.

	Se modificó el formulario de registro Register.cshtml, añadiendo mas campos y cambiando unos estilos

	Al momento de crear el usuario se usa el metodo CreateUser(), pero este metodo usa por defecto
	IdentityUser. Hay que cambiarlo por ApplicationUser, ya que esta clase hereda de IdentiyUser y
	contiene todo los demas campos que hemos agregado

	En OnPostAsync obtenemos tambien el resto de campos que estamos ingresando

12. Agreganos al InputModel RoleList para tener la coleccion para el drop down list
	En OnGetAsync
	Obtenemos la lista de roles a mostrarse en la pantalla de registro

	En Register.cshtl mostramos los roles en un select

	Obviamente en un entorno real este drop down no irira, pues el usuario que se registra
	no podria elegir su propio rol.

13. RegisterModel, en OnPostAsync
	Verificamos si el usuario selecciono un rol o no para registrarlo
	Pruebas:
	Creamos primero un usuario con el rol de Admin.
	Se registra el usuario en la tabla Users y se registra la relación User-Role en la tabla
	UserRoles (EL id del usuario y del rol)
	Creamos ahora un usuario sin rol.
	Se registra el usuario en la tabla Users y vemos en la tabla UserRoles que se le ha asignado
	por defecto el rol Individual

	user: admin@mail.com
	pass: Admin123@

14. En la pantalla de registro se creara un drop down con las compañias existentes. Este drop
	down solo aparece si se selecciona el rol "Company".
	Agregamos la propiedad CategoryId al modelo ApplicationUser
	Agregamos la migracion para agregar la nueva columna y actualizamos la BD
	Inyectamos UnitOfWork en RegisterModel
	Cremaos las propiedades CompanyList y Category en el InputModel
	Le signamos valores a CompanyList en OnGetAsync 
	Creamos un drop down para company en la pagina Register

15. En la pagina Register creamos en la seccion de scripts, con jquery, la funcionalidad para
	que el drop down aparezca solo si se selecciona el rol "Company"

16. En RegisterModel, en OnPostAsync
	Si Role es Company, obtenemos la company seleccionada en el drop down y registramos el
	usuario con su respectivo CategoryId

=========================================================================================================

Módulo 09: Shopping Cart

01. ShoppingCart modelo y DbSet
	Generar migracion y actualizar BD

	Add-Migration AddShoppingCartToDB
	Update-Database

	Asegurarse de tener seleccionado el proyecto BulkyBook.DataAccess

02. Creacion de Repositorio ShoppingCart y ApplicationUser (Interface y Clase)
	Uso de repositorios en UOW (Interface y Clase)

03. HomeController
	Details tanto GET como POST
	Algunos agregados a Details.cshtml

04. HomeController
	Details POST
	A mi me parece es que lo correcto seria que el repositorio tenga un metodo de actualizacion
	en el que se actualice la cantidad y no que se incremetne o decremente

05. Con esto se configura el escenario en el que se desea agregar un producto al carrito sin estar
    logueado. Lo que hace la aplicacion es rederigir a la pantalla de Login, mandando como parametro
	de retorno la pagina en la que uno estaba para que inmediatamente nos logueemos regresar a ella.
	El problema es que por defecto redirige a Account/Login y a esa dirccion le falta el Area Identity
	Identity/Account/Login.
	Para solucionar esto hay que hacer una configurcion en Program.cs

	options.LoginPath = $"/Identity/Account/Login";
    options.LogoutPath = $"/Identity/Account/Logout";
    options.AccessDeniedPath = $"/Identity/Account/AccessDenied";

06. Shopping Cart UI
	https://icons.getbootstrap.com/icons/cart/

07. Load Shopping Cart List in Get Action

08. Price calculation based on quantity

09. Cart Total

10. Updating Quantity in Shopping Cart

11. Cart Summary UI

=========================================================================================================

Módulo 10: Order Creation

01. Create Order Header and Details Model
    Crear migraciones
	Actualizar BD
	NOTA: No olvidar seleccionar BulkyBook.DataAccess como proyecto predeterminado

02. Add Order Header and Detail to UnitOfWork
    OrderHeader y OrderDetail. Repositorios y UnitOfWork

03. Summary GET Action Method
    Algunos cambios en Index y Summary en CartController

04. Load Summary UI with data

	NOTA: No estoy muy de acuerdo que reutilice el objeto ShoppingCartVM para el manejo de
	la orden. Yo utlizaría un objeto OrderVM que contendria objetos OrderHeader y OrderDetail
	para el manejo de todo la orden
    
05. Summary POST Action Method
    public IActionResult PlaceOrder(ShoppingCartVM sCartVM)

	- No queda claro como puede hacer tantos Add y Remove a la BD sin transacciones (todo o nada)
	  O ser que EF es lo suficientemente intekligente para saber que todo es una transaccion y
	  solo la confirmara si todo se ejecuta normalmente.
	- Sigo pensando que deberia usar session para mantener el carrito. Asi no tendria que estar
	  borrando el contenido de la tabla ShoppingCart al final o arriesgandose a que se quede data
	  registrada en esa tabla

06. Create Order	
    Probando que se registre la cabecera y el detalle de la orden. Y se borren los productos
	agregados en la tabla ShoppingCart

07. Create Stripe Account
    - Crear una cuenta en Stripe https://stripe.com/
	- En el dashboard https://dashboard.stripe.com/test/dashboard
	  Seleccionar New Bussiness en la parte superior izquierda
	- Ingresar un nombre de cuenta: BP_ASPNETMVC6_Demo. Click en Add Name
	  (No es necesario activar la cuenta siempre que la utilicemos en entorno de desarrollo)
	- En la seccióm Get started with Stripe, vemos a la derecha:
	  For developers
	  Publishable key: pk_test_51NLyrOC96OG52ESUxRQoKN0lJbCKLx5xc8hfi9wdSfUeFXyakeRrRuUj20W9ox4wgaZGP1ye57uzOmroTc9YY2HQ00ssqdd7Te
	  Secret key: sk_test_51NLyrOC96OG52ESU5pjpkodTi2FHYMGaiLGTaLlE0Selk8xNBgY9LiTamrntQ423RJhlZYyg1fCgljK98nskU1LJ0071afTLF6
	- En el menu "Developers" en la parte superior, podemos ver las llaves necesarias para usar
	  Stripe y nuestra actividad con la API de Stripe.
	  https://dashboard.stripe.com/test/apikeys

08. Stripe Secrets Configuration
	- Colocar la Publishable key y Secret key en appSettings.json
	- En BulkyBook.Utility crear la clase StripeSettings
	- En Program, obtenemos la configuracion de Stripe en las propiedades de StripeSettings
	  builder.Services.Configure<StripeSettings>(builder.Configuration.GetSection("Stripe"));
    - Instalar el paquete NuGet Stripe.net
	- Agregar la configuracion de Stripe a nivel global en la seccion de middlewares
	  StripeConfiguration.ApiKey = builder.Configuration.GetSection("Stripe:SecretKey").Get<string>();
    - En summary.cshtml, inyectamos la configuracion de Stripe
	  @using Microsoft.Extensions.Options
	  @inject IOptions<BulkyBook.Utility.StripeSettings> Stripe

09. Call Stripe from Summary Page
	https://stripe.com/docs/payments/accept-a-payment
	En CartController, en el action PlaceOrder colocaremos una configuracion de Stripe
	NOTA: Asegurarse de que la clase SessionCreateOptions este siendo usada del namespace 
	Stripe.Checkout y no de Stripe.BillingPortal

10. Save Stripe Session ID and Payment Intent ID
    En CartController, en el action PlaceOrder

11. Order Confirmation
    En CartController, creamos el action OrderConfirmation
	Creamos la vista OrderConfrmation

	NOTA: El action OrderConfirmation es llamado cuando le pago es exitoso (Ver configurción de 
	Stripe en el action PlaceOrder en CartController)

12. Payments in Action
    Prueba del pago de la orden
    - Estando en Summary, se hace click en Place Order y se lanza la pasarela de pago de Stripe
	- Ver los numeros de tarjeta con los que se puede testear
	  https://stripe.com/docs/testing?testing-method=card-numbers
	  Visa	4242424242424242	
	  Visa (debit)	4000056655665556
	  Mastercard	5555555555554444
	- Si la operacion es exitosa se lanza la vista de Confirmacion de Orden

	En nuestro dashboard en Stripe podemos ver los pagos realizados por ventas
	https://dashboard.stripe.com/test/payments


* Resumen del escenario en el que se trata de un usuario indivicual

MAKES PAYMENT  =====>  ORDER CONFIRMATION  =====>  PROCCESSING     =====>  SHIPPED
Status: Pending        Status: Approved            Status: Processing      Status: Shipped
Payment: Pending       Payment: Approved           Payment: Approved       Payment: Approved

En este caso el usuario individual selecciona los productos que quiere comprar y realiza el
pago en linea (confirmacion de orden). Esto genera que el payment tenga ya un estado Aprobado.
Las dos últimas etapas son realizadas por el administrador. Cuando la orden sera enviada (Shipped)
se generará un numero de seguimiento y datos del transportista que le seran proveidos al usuario
Y asi se completara todo el proceso de la orden en cuanto a un usuario individual.

=========================================================================================================

Módulo 11: Order Management

01. Flow for company user

* Resumen del escenario en el que se trata de un usuario company
  En este caso el flujo empieza con la confirmacion de la orden (Status: Aprobado y Payment:
  Aprobado para pago con retraso)

ORDER CONFIRMATION      =====>     PROCCESSING          =====>      SHIPPED
Status: Approved                   Status: Processing               Status: Shipped
Payment: ApprovedForDelayed        Payment: ApprovedForDelayed      Payment: ApprovedForDelayed

* Como se trata de una compañia, esta tendra un plazo para pagar desde el envio (shipped) de 
  la orden.
  Las etapas de Proccessing y Shipped son realizadas por el administrador, las otras dos
  (Orden Confirmation y Makes Payment) por el cliente company

SHIPPED            =====>          Makes Payment
Status: Shipped                    Status: Shipped
Payment: ApprovedForDelayed        Payment: Approved

02. Place Order for Company User

En el action PlaceOrder en CartController evaluamos si el usuario esta asociado a una company
o es un usuario individual y segun eso el damos valor a los estados de orden y de pago


=========================================================================================================

Módulo 12: MVC Advance Concepts

01. Authorization

02. Email Sender using MimeKit and MailKit

03. Test Email Sender
	Cuando lo probe en local no funcionó. Me aparecían errores relacionados a certificados TSL y 
	SSL no válidos
	Me parece que es porque la aplicacion la cree solo HTTP y no HTTPS.
	Vamos a probar cuando este subido en Azure a ver si funciona.
	Recordar que tamto Register como CartController tienen envio de email

04. SendGrid
    Para poder usar SendGrid necesitas tener un correo "remitente" con un dominio distinto a
	gmail, hotmail, yahoo, etc.
	Es decir, por ejemplo, un correo con dominio educativo o corporativo, etc
	

=========================================================================================================

Módulo 13: Seed Database and Azure Deployment

01. DbInitializer Interface
	- En appSettings.json colocamos en la cadena de conexion otro nombre de base de datos. Pues 
	  crearemos una BD en blanco para crear al iniciar la aplicacion los roles y el usuario Admin
	  BP_AspNetCore_BulkyBook2
	- En la consola del administrador de paquetes ejecutamos
	  Update-Database para crear la nueva BD vacia en la crearemos lo roles y el admin
	- En BulkyBook.DataAccess creaamos
	  DbInitializer / IDbInitializer
	  DbInitializer / DbInitializer

02. Implement DbInitializer
    - Implementamos la clase
      DbInitializer / DbInitializer
    - Implentamos el llamado a initialize() en Program.cs
	  builder.Services.AddScoped<IDbInitializer, DbInitializer>();

	  SeedDatabase();

	  void SeedDatabase()
	  {
		  using (var scope = app.Services.CreateScope())
		  {
			  var dbInitializer = scope.ServiceProvider.GetRequiredService<IDbInitializer>();
			  dbInitializer.Initialize();
		  }
	  }


=========================================================================================================

Módulo 26: Authorization (OLD COURSE)

06. Register with Google

- Instalar el paquete
  Microsoft.AspNetCore.Authentication.Google	

- Ingresar a console developer google
  https://console.cloud.google.com/apis/dashboard?hl=es&pli=1&project=youtube-pruebas-363500

- Crear un nuevo proyecto
  BookStore
  NOTA: Sin Organizacion

- Seleccionamos el proyecto creado "BookStore" y ahora vamos a agregarle aplicaciones
  haciendo click en "Habilitar APIs y Servicios"

- Seleccionamos Google+ API y lo habilitamos haciendo click en "Habilitar"

- En el menú de la izquierda seleccionar "Credenciales"

- En la pantalla de credenciales hace click en "Configurar pantalla de consentimiento"

- Seleccionar como tipo de usuario "Externo" y hacer click en "Crear"

- En Informacion de la aplicacion, agregamos como nombre "Bookstore".
  Agregamos un correo de asistencia (jzo2102@gmail.com)
  Agregamos info de contacto del desarrollador
  Hacemos click en "Guardar y Continuar"

- Volvemos a hacer click en "Credenciales"
  Y hacemos click en "Crear Credenciales" y selecciomamos "ID de cliente de OAuth"

- Seleccionamosomos como tipo de Aplicacion "Aplicacion Web" y le damos un nombre "BookStore Web"
  En Origenes autorizados de Javascript agregamos la sgte URI "http://localhost:5212".
  Podemos agregar todas aquellas URIs autorizadas. Tomarlo en cuenta cuando pasemos a produccion
  En URI de redireccionamiento autorizado colocamos: http://localhost:5212/sigin-google
  Finalmente hacemos click en "Crear"

- Se muestra una ventana con el Id y el Secret creado.

- En Program.cs agregamos la configuracion para la autenticacion con google
  builder.Services.AddAuthentication().AddGoogle(options =>
  {
      options.ClientId = "936304635120-m1dvc620t81t10llmjtr8ivv0epj43l1.apps.googleusercontent.com";
      options.ClientSecret = "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";
  });

- Al ejecutarlo no funcionó y me parce que es porque la solicitud se esta haciendo desde una
  direccion HTTP y no HTTPS, por lo que Google la toma como insegura.
  Quizá cuando lo suba a Azure si funcione






Usando JSON en C#
https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-8-0

BP_AspNetCore_BulkyBook:

user: admin@mail.com
pass: Admin123@

user: jzo2102@hotmail.com  (Usuario individual)
pass: Indi123@

user: emp@mail.com (Usuario empleado)
pass: Empp123@

user: jzo2102@gmail.com  (Usuario individual)
pass: Robe123@

BP_AspNetCore_BulkyBook2:

user: admin@bookstore.com
pass: Admin123@


RECORDAR:
-Recordar descomentar las lineas de envio de email en Register.cshtml cuando lo suba a produccion
-Recordar descomentar las lineas de envio de email en CartController.cshtml cuando lo suba a produccion
-Recordar commentar las limeas en el try catch en Dbinitializer que son las lineas de ejecucion de 
las migraciones. En produccion no quiero que haga eso
-Desplegue en mi IIS local para tenr una dirccion HTTPS y probar el registro y login con Google.
pero aun asi no funciono. Tampoco funciono el envio de correo. He comentado todas esas funcionalidades
para no usarlas. De todas maneras podria probar si funcionan cuando despliegue la App en Azure

NOTA: Para desplegar en IIS y funcione me guie de un video de F Gavilan
G:\CURSOS\NETCORE\WEB API RESTFUL\Udemy(FG) - Web APIs RESTful con ASP.Net Core\6.0 (ESP)\Legacy\10 Despliegues
Tambien hay otro video en 
G:\CURSOS\NETCORE\WEB API RESTFUL\Udemy(FG) - Web APIs RESTful con ASP.Net Core\6.0 (ESP)\10. Despliegues
Pero el primero me ayudo bastante



* HOSTING GRATUITO PARA LA BD
https://freeasphosting.net/

-Al momento de crear la base de datos en FreeAspHosting 
BD nombre: gazoo80_bookstore
user: gazoo80
pass: saxp

-Para la cadena de conexion:
Server Name: sql.bsite.net\MSSQL2016   
Username: gazoo80_bookstore
Password: saxp


// Cadena de conexion en local
"DefaultConnection": "Data Source=PCHOME\\PCCASA; Initial Catalog=BP_AspNetCore_BulkyBook; User=sa; Password=sax"

// Cadena de conexion en produccion usando la BD en FreeAspHosting
"DefaultConnection": "Data Source=sql.bsite.net\\MSSQL2016; Initial Catalog=gazoo80_bookstore; User=gazoo80_bookstore; Password=saxp"


NOTA: Falta colocar la cadena de conexion en La Configuration del AppService. En este momento esta
funcionando con las cadenas de conexion en appSettings.json